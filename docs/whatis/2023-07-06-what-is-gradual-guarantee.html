<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>TYPES.HK - What Is Gradual Guarantee?</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">TYPES.HK</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
            </nav>
        </header>

        <main role="main">
            <h1>What Is Gradual Guarantee?</h1>
            <article>
    <section class="header">
        Posted on July  6, 2023
        
    </section>
    <section>
        <p><strong>Warning: Don’t read. Till then, I haven’t really understood all the details, give me some time to sort it out</strong></p>
<div class="ask">
<p>Any prerequisites before reading this post?</p>
</div>
<div class="answer">
<p>I suggest reading Jeremy Siek’s <a href="https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/">What is Gradual Typing</a>, which gives an intuitive explanation of gradual typing.</p>
</div>
<div class="ask">
<p>Okay, so why are you curious about gradual guarantee?</p>
</div>
<div class="answer">
<p>There’re three main reasons:</p>
<ul>
<li><p>When I was a Racket fan during my undergraduate, I was informed and curious that Typed Racket is a well-designed gradual language and there’s a soundness proof which is ensured by a contract system that interacts between Racket (untyped) and its type system.</p></li>
<li><p>One of my colleagues keeps working on designing gradual type systems, and she’s given many talks involved with gradual guarantee in our seminars, shamelessly, I never really got its idea.</p></li>
<li><p>Sometimes I learn some formalisation techniques from Jeremy Siek’s gradual-typing-in-agda. It might be a good chance to study GTLC (Gradually Typed Lambda Calculus) seriously.</p></li>
</ul>
</div>
<div class="ask">
<p>Then, why should I learn about it?</p>
</div>
<div class="answer">
<p>Gradual guarantee has already been widely taken as a criteria in designing gradual type systems.</p>
</div>
<div class="ask">
<p>So, what does the gradual guarantee guarantee?</p>
</div>
<div class="answer">
<p>Good point. It guarantees that:</p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>I will also show explanations in a formal way (how it hits the theorem).</p>
</div>
<div class="answer">
<p>Let’s just check the theorem first, it’s taken from <a href="https://drops.dagstuhl.de/opus/volltexte/2015/5031/pdf/21.pdf">Refined Criteria for Gradual Typing</a>.</p>
</div>
<div class="answer">
<p>Suppose <span class="math inline"><em>e</em> ⊑ <em>e</em>′</span> and <span class="math inline"> ⊢ <em>e</em> : <em>T</em></span>.</p>
<ul>
<li><p><span class="math inline"> ⊢ <em>e</em>′ : <em>T</em>′</span> and <span class="math inline"><em>T</em> ⊑ <em>T</em>′</span>.</p></li>
<li><p>If <span class="math inline"><em>e</em> ⇓ <em>v</em></span>, then <span class="math inline"><em>e</em>′ ⇓ <em>v</em>′</span> and <span class="math inline"><em>v</em> ⊑ <em>v</em>′</span>. If <span class="math inline"><em>e</em>⇑</span> then <span class="math inline"><em>e</em>′⇑</span>.</p></li>
<li><p>If <span class="math inline"><em>e</em>′ ⇓ <em>v</em>′</span>, then <span class="math inline"><em>e</em> ⇓ <em>v</em></span> where <span class="math inline"><em>v</em> ⊑ <em>v</em>′</span>, or <span class="math inline"><em>e</em> ⇓ <em>b</em><em>l</em><em>a</em><em>m</em><em>e</em><sub><em>T</em></sub><em>l</em></span>. If <span class="math inline"><em>e</em>′⇑</span>, then <span class="math inline"><em>e</em>⇑</span> or <span class="math inline"><em>e</em> ⇓ <em>b</em><em>l</em><em>a</em><em>m</em><em>e</em><sub><em>T</em></sub><em>l</em></span>.</p></li>
</ul>
</div>
<div class="ask">
<p>What do these notations mean?</p>
</div>
<div class="answer">
<ul>
<li><p><span class="math inline"> ⊢ <em>e</em> : <em>T</em></span> and <span class="math inline"><em>e</em> ⇓ <em>v</em></span> are what we are familiar with, they mean that <span class="math inline"><em>e</em></span> is well-typed and <span class="math inline"><em>e</em></span> evaluates to <span class="math inline"><em>v</em></span>.</p></li>
<li><p><span class="math inline"><em>T</em> ⊑ <em>T</em>′</span> means that <span class="math inline"><em>T</em></span> is more precise than <span class="math inline"><em>T</em>′</span> and <span class="math inline"><em>e</em> ⊑ <em>e</em>′</span> means that <span class="math inline"><em>e</em></span> is more precisely annotated than <span class="math inline"><em>e</em>′</span>.</p></li>
</ul>
</div>
<div class="ask">
<p>What about the theorem then?</p>
</div>
<div class="answer">
<p>The first theorem is called “static gradual guarantee”, it simply tells you that making terms more dynamic doesn’t affect its well-typedness.</p>
<p>Note here “more dynamic” means that you can replace the annotation to a less precise one, for example, changing <span class="math inline"><em>λ</em><em>x</em> : <em>I</em><em>n</em><em>t</em>. <em>x</em></span> to <span class="math inline"><em>λ</em><em>x</em> :  * . <em>x</em></span>.</p>
</div>
    </section>
</article>

        </main>

        <footer>
            Site powered by Hakyll</a>
        </footer>
    </body>
</html>
