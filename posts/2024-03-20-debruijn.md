---
title: De Bruijn Indices, in TAPL and PLFA style
---

In this article, we demostrate two ways in STLC using Agda with well-scoped syntax.
The reason of choosing Agda is author's familiarity; the reason of choosing
well-scoped syntax is that it is less error-prone to write code without losing scalability. One more virtue perhaps is the types of many operations are self-explanatory.

You can use another proof assistant of course, and you can use plain syntax by just erasing the indices in the datatype.

## Commons

Types are two instances: Int and Function type.

```agda
data Type : Set where
  Int    : Type
  _`→_   : (A : Type) → (B : Type) → Type
```

Terms are indexed by a number, which speficies the number of free variables can be used in the term. There're four instances:

* literal numbers: it is a term with artibirary number of free variables;
* variables: the number can only be less than the index, we use `Fin n` to do this;
* lambdas: the body has one more free variable than the expression since one variable is introduced by the binder;
* applications: both subterms have the same number of free variables.

```agda
data Term : ℕ → Set where
  lit   : (i : ℕ) → Term n
  `_    : (x : Fin n) → Term n
  ƛ_⇒_  : (A : Type) → (e : Term (1 + n)) → Term n
  _·_   : (e₁ : Term n) → (e₂ : Term n) → Term n
```

We model contexts by a datatype, use `Vector` is also a good choice.
The context is also indexed by a number with the same meaning as the term.

* A empty context has no free variables;
* A context followed by a type has one more free variable;

The contexts are accessed by a number, which defines on simutanious induction of the context and the number until we reach the `#0`.
Note that the type `Context n → Fin n → Type` ensures that we can always find the type of a variable in a context.

```agda
infix 6 _,_

data Context : ℕ → Set where
  ∅     : Context 0
  _,_   : Context n → (A : Type) → Context (1 + n)

infix 3 _∋_⦂_
data _∋_⦂_ : Context n → Fin n → Type → Set where
  Z : ∀ {Γ : Context n} {A}
    → Γ , A ∋ #0 ⦂ A
  S : ∀ {Γ : Context n} {k A B}
    → Γ ∋ k ⦂ A
    → Γ , B ∋ #S k ⦂ A
```

Right now we reach the point that could differ: how to define the shift/subst? And how to state and prove the weakening and substituition lemma.

## TAPL style of De Bruijn Indices

## PLFA style of De Bruijn Indices

## References

We list the choices of some formalisation take:

* [coq-community/dblib](https://github.com/coq-community/dblib) defines lift (shift) in TAPL style.
* [coq-community/autosubst](https://github.com/coq-community/autosubst) choose the PLFA style.
* [Vouillon's solution](https://www.seas.upenn.edu/~plclub/poplmark/) is TAPL style.


## My story of binding (Feel free to skip)

At the first meeting, my advisor dropped me a paper around forty pages: [Locally nameless](https://chargueraud.org/research/2009/ln/main.pdf), along with serveral tutorials of formalisation of lambda calculus in Coq. In that day, I got to know that our group mostly deals with binders using this lib/technique. If someone want a newer version, there is a alternative library maintained by plclub.

I was happy at that moment, actually in my first two years of research, choose
which binding techniques in the formalisation does not trouble me: just use one widely used by our group.

The main reasons I decided to take a closer look at de Bruijn are two:

* In recent POPLmark panel discussion, the survey from BCP said "more and more people stick to old good de Bruijn";
* I switched to Agda in my second project, where de bruijn is mostly used.
